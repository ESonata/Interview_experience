## Java虚拟机

### java内存区域和内存溢出异常

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。

1. 程序计数器

   程序计数器，**它可以看做是当前线程所执行的字节码的行号指示器。**字节码解释器工作时，就是通过这个计数器的值Laura选取下一条需要执行的字节码指令。

   由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的。在任何一个确定的时间，一个处理器只会执行一条线程中的指令。因此，**为了线程切换后能够恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。**

   它是线程私有的，不会发生内存溢出的一块区域。

2. Java虚拟机栈

   **Java虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。**

   **每个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。**

   Java虚拟机栈是线程私有的。

   在Java虚拟机规范中，定义了两种异常状态：

   + Java虚拟机栈容量是不能扩展的，且当前线程申请的栈深度大于虚拟机栈的深度，那么会抛出StackOverflowError异常；
   + Java虚拟机栈容量是能够扩展的，且当前线程申请的栈深度大于虚拟机栈的深度，但是栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。
   
3. 本地方法栈

   本地方法栈与虚拟机栈所发挥的作用是非常相似的，**它们之间的区别不过是虚拟机栈为虚拟机栈执行Java方法（也就是字节码）服务，而本地方法栈则是为了虚拟机栈使用的Native方法服务。**

   与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

4. Java堆

   对多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。**Java堆是被所有线程共享的一块内存，在虚拟机启动时创建。**

   此内存区域的唯一目的：存放对象实例，**几乎所有的对象实例都在此分配实例**。

   随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术，导致不是所有的对象都在Java堆上分配。

   Java堆可以处于物理上不连续的内存空间，但在逻辑上它应该被视为连续的。

   Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展的来实现的。**如果在Java堆中没有内存完成实例分配，并且无法再扩展时，Java虚拟机将会抛出内存溢出的异常。**

5. 方法区

   方法区与Java堆一样，是各个线程共享的内存区域，**它用于存储已被虚拟机加载的类信息，常量、静态变量、即时编译器后的代码缓存等数据。**
   Hotspot虚拟机之前用永久代实现方法区，JDK8之后就用元空间代替了永久代。

   除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还**可以选择不实现垃圾收集**。

   这个区域的垃圾回收目的主要是**针对常量池的回收和对类型的卸载。**

   **如果方法区无法满足新的内存分配需求时，将抛出内存溢出异常。**

   

### 垃圾收集器和内存分配策略

1. 对象存活算法

   + 引用计数法

     给对象添加一个计数器，每当有一个地方引用它时，计数器就加1，当引用失效时，计数器就减1。任何时刻计数器为0的对象就是不可能再被使用。主流的Java虚拟机里面没有选用引用计数算法来管理内存，**因为它很难解决对象之间循环引用的问题。**

   + 可达性分析法

     在主流的商用程序语言中，都是通过可达性分析判断对象是否存活。

     这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这种节点开始向下搜索，搜索走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象不可达。在Java语言中，可作为GC Roots的对象包括以下几种：

     + 虚拟机栈（栈中本地变量表）中引用的对象。
     + 方法区中类静态属性引用的对象
     + 方法区中常量引用的对象
     + 本地方法栈中JNI（一般说的Native方法）引用的对象。

2. 回收方法区

   方法区的垃圾收集主要回收两部分内容：**废弃的常量和不在使用的类型**。

   常量回收与Java堆中对象的回收类似。如果没有其他地方引用了这个常量，发生了内存回收，这个常量会被系统清理出常量池。

   类需要同时满足3个条件才能算是“无用的类”：

   + 该类所有的实例都已经被回收了，也就是Java堆中不存在该类以及其他任何派生子类的实例。
   + 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，否则很难达成的。
   + 该类对应的Java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类。

3. 垃圾收集算法

   + 分代收集算法

     两个假说：

     + 弱分代假说：绝大数的对象都是朝生夕灭的。
     + 强分代假说：熬过多次垃圾收集过程的对象就越难消亡。

     设计原则：收集器应该将Java堆划分出不同的公共区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域中存储。

   + 标记-清除算法

     首先标记出所有的需要回收的对象，在标记完成后，同一回收掉所有被标记的对象**。**

     **它有两个主要的缺点**：

     + 执行效率不稳定，标记和清除两个过程的执行效率都随对象数量的增长而降低。
     + 内存空间碎片化问题。标记清除之后会产生大量不连续的内存碎片。

   + 标记-复制算法：

     “半区复制”：将内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存使用完毕之后，就将还存活的对象复制到另一块上面去，然后再把已使用过的内存空间一次清理掉。

     缺点：将可用内存缩小为原来的一半。

     Appel回收：将新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时，将Eden和已用过的那块Survivor空间仍然还存活的对象复制到另一块Survivor上，然后直接清理掉Eden和已用过的那块Survivor空间。

     **当Survivor空间不足以容纳一次回收之后存活的对象，就需要依赖其他内存区域（实际上大多是老年代）进行分配担保机制。**

   + 标记-整理算法

     首先标记处存活的对象，然后让所有存活的对象向内存空间的一端移动，然后直接清理掉边界外的内存。

     如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活的区域，移动存活对象并将更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作是**必须全程暂停用户应用程序才能进行**。

4. 经典的垃圾收集器

   + Serial收集器

     它只会使用一个CPU或一条收集线程去完成垃圾收集工作，**它进行垃圾收集的时候，必须暂停其他所有的工作线程，直到它收集结束。**

     优点：与其他收集器的单线程比，简单高效。

     对于限定单个CPU的环境来说，Serial收集器没有线程交互的开销。

   + ParNew收集器

     ParNew它是许多运行在Server模式下的虚拟机**首选**的新生代收集器。因为除了Serial收集器外，目前只有它能够与CMS收集器一起使用。

   + Parallel Scavenge收集器（吞吐量收集器）

     Parallel Scavenge 收集器是新生代收集器，使用的复制算法，并行的多线程收集器。

     **CMS等收集器的关注点是极可能地缩短垃圾收集时用户线程停顿时间。**而Parallel Scavenge收集器的目标是**达到一个可控的吞吐量**。

     吞吐量就是CPU用于运行代码消耗时间与CPU总消耗时间的比值。

     高吞吐量可以高效的利用CPU时间，尽快完成程序的运算任务，适合在后台运算且不需要太多交互的任务。

   + Serial Old收集器

     Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-清理”算法。

     **可以作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。**
     
   + Parallel Old 收集器
   
     Parallel Old是Parallel Scavenge 收集器的老年代版本，使用多线程和“标记—整理”算法。
   
5. CMS收集器

   CMS（Concurrent Mark Swap）收集器，是一种**以获取最短回收停顿时间为目的的收集器**。CMS收集器是基于“标记—清除”算法实现的，它的运作过程分成四个步骤：

   + 初始标记：仅仅标记一下GC roots能直接关联到的对象，速度很快。
   + 并发标记：从GC roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长，但是不需要停顿用户线程。
   + 重新标记：为了修正并发标记期间，因为用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。
   + 并发清除：清理删除标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

   **其中初始标记、重新标记这两个步骤仍然需要“Stop the world”**。

   由于整个过程中，耗时最长的并发标记和并发清理过程，收集器都可以与用户线程一起工作，所以，从总体来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。

   **CMS收集器的优点：并发收集、低停顿；**

   **CMS收集器的缺点：**

   + CMS对CPU资源敏感，她虽然不会导致用户线程停顿，但是会因为占用一部分线程或者CPU资源而导致应用程序变慢。

   + CMS无法处理“浮动垃圾”，可能出现“Concurrent Mode Failure”（并发失败）失败而导致另一次Full GC的产生。

     由于CMS的并发标记和并发清理阶段，用户线程还在运行着，伴随着程序运行自然就会有新的垃圾不断产生，这一部分垃圾出现在标记过程结束之后，CMS无法在当次垃圾收集中处理它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾被称为“浮动垃圾”。

     垃圾收集阶段用户线程还需运行，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了在进行垃圾收集。

     如果CMS运行期间预留的内存无法满足程序分配新对象的需要，就会产生并发失败（“Concurrent Mode Failure”）。这是虚拟机就会使用Serial Old 收集器回收垃圾。

   + CMS是一款基于“标记—清理”算法实现的收集器，就意味着会收集结束会产生大量空间碎片产生。

6. G1收集器

   G1收集器是一款面向服务端应用的垃圾收集器，作为CMS收集器的代替者和继承人，设计者们希望作出一款能够建立起“停顿时间模型”的收集器。停顿时间模型的意思是：能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标。

   **G1收集器面向堆内存任何部分来组成回收集进行回收，衡量标准不再是它属于哪一个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大。**

   虽然G1也是仍然遵循分代收集理论收集的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分成多个大小相等的独立区域，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间或者老年代空间。

   虽然G1仍然保存新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。G1收集器之所以能够建立可预测的停顿时间模型，因为它将Region作为单次回收的最小单元，即每次收集到的内存区域都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。

   **G1收集器的运作过程大致可划分为以下四个步骤：**

   + 初始标记：仅仅是标记一下GC Root是能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能够正确地在可用的Region中分配对象。**这个阶段需要停顿线程。**
   + 并发标记：从GC Roots开始对堆内对象进行可行性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时比较长，但可与用户程序并发执行。当对象图扫描完毕之后，还需要重新处理SATB记录下的在并发时有引用变动的对象。
   + 最终标记：**对用户线程做另一个短暂的停顿**，用于处理并发阶段结束后仍然遗留的最后那少量的SATB记录。
   + 筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region，再清理掉整个旧Region的全部空间。**这里的操作涉及到存货对象的移动，是必须暂停用户线程，由多条收集线程并行完成。**、

7. 内存分配和回收策略

   Java技术体系中的自动内存管理，最根本的目标是自动化地解决了两个问题：**自动给对象分配内存和自动回收分配给对象的内存**。

   几条最普遍的内存分配规则：

   + 对象优先在Eden分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次垃圾回收集。
   + 大对象直接进入老年代。
   + 长期存活的对象进入老年代。虚拟机给每个对象定义了一个对象年龄（Age）计数器，如果对象在Eden中出生，并经过第一次Minor GC后，仍然存活，并且能被Survivor容纳的话，将移动到Survivor空间，并且对象年龄为1，对象在Survivor区中熬过一次Minor GC，年龄增加1岁，当它的年龄达到一定程度（默认15岁），就将会被晋升到老年代。
   + 动态年龄判定。如果Survivor空间中相同年龄的对象的总和大于Survivor空间的一般，年龄大于等于该年龄的对象就可以直接进入老年代。

### 虚拟机加载机制

Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作**虚拟机的类加载机制**。

1. 类加载的过程

   一个类型从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段。其中验证、准备、解析三个部分被统称为连接（Linking）。

   + 加载

     在加载阶段，Java虚拟机需要完成以下三件事：

     + 通过一个类的全限定名来获取定义此类的二进制字节流。
     + 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
     + 在内存中生成一个代表这个类的Java.lang.Class对象，作为方法区这个类的各类数据的访问入口。

     加载阶段既可以用Java虚拟机内置的类引导类加载器来完成，也可以由用户自定义的类加载器去完成。

     加载阶段与连接阶段的部分动作（如一部分字节码文件的格式校验动作）时交叉进行的。

     简单说就是，Load阶段读取类文件产生二进制流，并转化为特定的数据结构，然后创建对应类的java.lang.Class实例。在这个阶段会发生初步检验cafe babe魔法数、常量池、文件长度、是否有父类等信息。

   + 验证

     验证是连接阶段的第一步，**这一阶段的目的是确保Class文件中的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，**保证这些信息被当做代码运行后不会危害虚拟机的自身的安全。

     验证阶段大致会完成下面四个阶段的检验工作：

     + 文件格式检验：验证字节流是否符合Class文件格式的规范，并且能够被当前版本的虚拟机处理。如：是否以魔数0xCAFEBABE开头等。
     + 元数据验证：对类的元数据信息进行语义检验。如：这个类是否有父类。（除了Java.lang.Class之外，所有的类都应该哟父类）。
     + 字节码验证：确定程序语义是合法的、符合逻辑的。
     + 符号引用验证：发生在虚拟机将符号引用转化为直接引用的时候。

   + 准备

     准备阶段是正式为类中的静态变量（被static修饰的变量）分配内存并设置类变量初始值的阶段。

     准备阶段进行内存分配不包含实例变量，实例变量将会在对象实例化时，随着对象一起分配在Java堆中。

     这里说的初始值通常情况是数值类型的零值。

     ```java
     private static int value=123;
     ```

     那变量在准备阶段之后的初始值是 0 而不是123 。将value赋值为123的操作需要到类的初始化阶段之后才能被执行。

     特殊情况，如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值。

     ```java
     public static final int value=123;
     ```

     在准备阶段虚拟机就会根据ConstantValue设置value为123。

   + 解析

     **解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。**

     **符号引用**：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义地定义到目标即可。符号引用与虚拟机实现的内存布局无关，**引用的目标并不一定是已经加载到虚拟机当中的内容。**

     **直接引用**:直接引用是可以直接指向目标的指针、相对偏移量或者是一个能直接定位到目标的句柄。**直接引用是和虚拟机实现的内存布局直接相关的**，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。

     解析动作主要是针对类或者接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。

     如果有了直接引用，那么引用的目标必定已经在虚拟机的内存中存在。

     Link阶段包括验证、准备、解析三个步骤。

     + 验证是更详细的校验，比如final是否合规、类型是否正确、静态变量是否合理等。
     + 准备阶段是为静态变量分为内存，并设定为默认值，解析类和方法确保类与类之间的相互引用正确性，完成内存结构布局。

   + 初始化

     类的初始化阶段是类加载过程的最后一个步骤。之前几个类加载步骤的动作里，除了在加载阶段用户应用程序可以通过自定义的类加载器和方式局部参加外，其余动作都是完全由Java虚拟机来主导控制的。直到初始化阶段，Java虚拟机才真正开始执行编写Java程序代码。

     进行准备阶段，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码指定的主观计划去初始化类变量和其他资源。初始化阶段就是执行类构造器<clinit>方法的过程。

     <clinit>并不是程序员在Java代码中直接编写的代码，而是Javac编译器的自动生成物。

     总而言之，Init阶段执行类构造器<clinit>方法，如果赋值运算是通过其他类的静态方法来完成的，那么会马上解析另外一个类，在虚拟机栈中执行完毕后通过返回值进行赋值。

   类加载就是一个将.class 字节码文件实例化成Class对象并进行相关初始化的过程。在这个过程中，JVM会初始化继承树上还没有被初始化的所有父类，并且也会执行这个链路上所有为执行过的静态代码块、静态变量赋值语句等。某些类在使用时，也可以按需由类加载器进行加载。
   
2. 类加载器与双亲委派模型

   + 类加载器：“通过一个类的限定名来获取描述该类的二进制字节流。”这个动作是由“类加载器”实现的。

   + 双亲委派模型：

     站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器，这个类加载器是使用C++实现的，是Java虚拟机的一部分，另外一种就是其他所有的类加载器，这些类加载器都由Java语言实现，独立在虚拟机外。

   